<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fabric Rip Poster — 2D Canvas (Verlet)</title>
  <link href="https://fonts.googleapis.com/css2?family=Krona+One&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Pixelify+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root{ --bg:#F6E8DF; --ink:#0A1B58; --cover:#F03B2C; }
    html,body{ height:100%; margin:0; background:var(--cover); display:grid; place-items:center; }
    #stage{ position:relative; width:min(92vw,1100px); 
  
    
    height:calc(min(92vw,1100px)*1.414); max-height:92vh; border-radius:16px; overflow:hidden; box-shadow:0 14px 36px rgba(0,0,0,.3); background:var(--bg); }
    #c{ width:100%; height:100%; display:block; }
    /* Intro overlay */
    .intro{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.0); pointer-events:auto; }
    .intro-inner{ background:#B31313; color:#000; box-sizing:border-box; width:clamp(220px, 36vw, 380px); aspect-ratio:1/1; padding:20px; border-radius:10px; box-shadow:0 8px 28px rgba(0,0,0,.35); text-align:center; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; gap:8px; opacity:0; transform:translateY(12px) scale(0.98); transition:opacity .45s cubic-bezier(.2,.8,.2,1), transform .45s cubic-bezier(.2,.8,.2,1); }
    .intro.show .intro-inner{ opacity:1; transform:none; }
         .intro-title{ font-family:'Pixelify Sans',sans-serif; font-weight:700; letter-spacing:2px; color:#000; font-size:clamp(20px, 4.2vw, 30pt); line-height:clamp(18px, 3vw, 23pt); white-space:pre-line; }
    .intro-btn{ margin-top:0; background:#111; color:#F03B2C; border:none; padding:10px 18px; border-radius:8px; font-family:'Pixelify Sans',sans-serif; font-weight:700; letter-spacing:1px; font-size:14px; cursor:pointer; transition:transform .1s ease, background .2s ease, color .2s ease; }
    .intro-btn:hover{ background:#FFD700; color:#000; }
    .intro-btn:active{ transform:translateY(1px) scale(0.99); color:#ff7a6f; }
    .intro-note{ margin-top:auto; color:#111; opacity:0.85; font:12px/1.4 'Courier Prime', monospace; }
    .intro.hidden{ pointer-events:none; }
    .intro.hidden .intro-inner{ opacity:0; transform:translateY(8px); }
    .intro-center{ margin:auto 0; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:24px; padding-top:48px; padding-bottom:0; }

    /* Responsive tweaks */
    @media (max-width: 520px){
      .intro-inner{ width:clamp(260px, 86vw, 420px); padding:16px; }
      .intro-center{ gap:30px; padding-top:44px; }
      .intro-title{ font-size:clamp(26px, 8vw, 30pt); line-height:clamp(22px, 5.6vw, 23pt); }
      .intro-btn{ padding:14px 20px; font-size:15px; }
      .intro-note{ font-size:11px; }
    }
    @media (min-width: 900px){
      .intro-center{ gap:50px; padding-top:60px; }
    }
    /* Simplified HUD collapsed: a small square button */
    .hud.collapsed{ width:auto; height:auto; padding:0; background:transparent; box-shadow:none; border-radius:10px; }
    .hud.collapsed .hud-header{ padding:6px; background:#fff; border:1px solid rgba(0,0,0,.15); border-radius:10px; box-shadow:0 4px 14px rgba(0,0,0,.18); }
    .hud.collapsed .hud-header span{ display:none; }
    .hud.collapsed .btn-toggle{ width:24px; height:24px; font-weight:bold; }
    .hud.collapsed .hud-content{ display:none; }
   
    .hud{ position:absolute; right:12px; bottom:12px; background:rgba(255,255,255,.88); color:#111; border-radius:12px; font:12px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; backdrop-filter:blur(6px); box-shadow:0 6px 18px rgba(0,0,0,.15); max-width:320px; overflow:hidden; transition:all 0.3s ease; }
    .hud-header{ display:flex; justify-content:space-between; align-items:center; padding:10px 12px; background:rgba(255,255,255,.95); border-bottom:1px solid rgba(0,0,0,.1); }
    .hud-content{ padding:10px 12px; }
    .hud.collapsed .hud-content{ display:none; }
    .hud.collapsed .hud-header{ border-bottom:none; }
    .btn-toggle{ background:none; border:none; font-size:18px; cursor:pointer; color:#111; padding:0; width:20px; height:20px; display:flex; align-items:center; justify-content:center; }
    .hud label{ display:block; margin-top:6px; }
    .kbd{ padding:2px 5px; border-radius:6px; background:#111; color:#fff; font-size:11px; }
    .row{ display:flex; gap:6px; flex-wrap:wrap; margin-top:6px; }
    .toggled{ background:#111 !important; color:#fff !important; }
    .btn{ padding:6px 10px; border-radius:8px; border:1px solid rgba(0,0,0,.15); background:#fff; cursor:pointer; font:12px/1 system-ui; }

    /* Mini reset button (bottom-left), matching collapsed HUD square */
    .mini-reset{ position:absolute; left:12px; bottom:12px; background:#fff; border:1px solid rgba(0,0,0,.15); width:36px; height:36px; border-radius:10px; display:flex; align-items:center; justify-content:center; box-shadow:0 4px 14px rgba(0,0,0,.18); cursor:pointer; transition:background .2s ease, transform .05s ease; }
    .mini-reset:hover{ background:#f6f6f6; }
    .mini-reset:active{ transform:translateY(1px); }
    .icon-refresh{ font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif; font-weight:700; font-size:18px; line-height:1; color:#111; display:flex; align-items:center; justify-content:center; width:20px; height:20px; }
    .icon-refresh:before{ content:none; }
    .icon-refresh:after{ content:none; }
  </style>
</head>
<body>
      <div id="stage">
      <canvas id="c"></canvas>
      <button id="mini-reset" class="mini-reset" title="Reset">
        <span class="icon-refresh" aria-hidden="true">↻</span>
      </button>
      <div id="intro" class="intro show">
        <div class="intro-inner">
          <div class="intro-center">
            <div class="intro-title">UNWRAP<br>ROULETTE</div>
            <button id="start-btn" class="intro-btn">START</button>
          </div>
          <div class="intro-note">The gift? Who cares.<br>The unwrap? That’s the fun part.<br>Drag, tear, refresh. Repeat.</div>
        </div>
      </div>
      <div class="hud collapsed" id="hud">
        <div class="hud-header">
          <span><b>Rip</b>: left‑drag to tug · <span class="kbd">Right‑drag</span> to cut · <span class="kbd">R</span> to reset</span>
          <button id="toggle-hud" class="btn-toggle">+</button>
        </div>
        <div class="hud-content">
          <label>Line thickness <input id="thick" type="range" min="0.3" max="2.2" step="0.05" value="0.9"></label>
          <label>Brush size <input id="brush" type="range" min="5" max="40" value="20"></label>
          <label>Eraser size <input id="eraser" type="range" min="6" max="80" value="26"></label>
          <label>Tear distance <input id="tear" type="range" min="10" max="80" value="40"></label>
          <label>Gravity <input id="grav" type="range" min="50" max="1200" step="50" value="200"></label>
          <label>Pattern <select id="pattern">
            <option value="random">Random</option>
            <option value="checkerboard">Checkerboard</option>
            <option value="polka-dots">Polka Dots</option>
            <option value="stripes">Stripes</option>
            <option value="squares">Squares</option>
            <option value="circles">Circles</option>
            <option value="zigzag">Zigzag</option>
            <option value="diamonds">Diamonds</option>
            <option value="stars">Stars</option>
          </select></label>
          <div class="row">
            <button id="toggle-eraser" class="btn">Eraser (E)</button>
            <button id="reset-thick" class="btn">Reset thickness</button>
            <button id="reset" class="btn">Reset (R)</button>
            <button id="save" class="btn">Export PNG (⌘/Ctrl+S)</button>
          </div>
        </div>
      </div>

    </div>

<script>
// ====== Krona One poster background ======
const poster = document.createElement('canvas');
const pctx = poster.getContext('2d');

// Hidden presents that change with each reset
const hiddenPresents = [
  // Nice / Fun Presents
  'A beach vacation', 'Unlimited wine (boxed only)', 'Free gym membership (closes tomorrow)', 'Romantic dinner (microwave lasagna)',
  'Free Netflix forever', 'Michelin-star dinner', 'Three weeks of massage', 'A spa weekend',
  'Your dream sneakers', 'First-class upgrade', 'A puppy (good luck)', 'Year of free coffee',
  'Private karaoke night', 'A rooftop party', 'Concert tickets',
  
  // Boring / Lame Presents
  'Expired coupon', 'Hotel soap (half used)', 'Bag of ice (already melted)', 'Broken pencil',
  'Free dust', 'Half a stapler', '2% battery', 'Empty box', 'Parking ticket',
  'One unread email', 'Used chewing gum', 'Random USB cable', 'Plant (already dead)',
  '"World\'s Okayest" sticker', 'Free trial (already expired)', 'Lonely sock',
  'Excel spreadsheet', 'Pocket lint', 'Free advice (unwanted)', 'Monday morning', 'Tariffs',
  
  // Weird / Experiential Mix
  'Silent retreat (someone snores)', 'Karaoke with strangers', '10 minutes of fame', 'All-you-can-scroll WiFi',
  'A Zoom-free Monday', 'Your ex\'s playlist', 'Breakfast in bed (served by yourself)',
  'A free therapy session (DIY)', 'Boat cruise (seasick guarantee)', 'One drama-free week',
  'Lifetime supply of eye rolls', 'Random side quest unlocked'
];

let currentHiddenPresent = 'A beach vacation';

function clamp01(x){ return Math.max(0, Math.min(1, x)); }
function hexToHsl(hex){
  let h = hex.replace('#','');
  if(h.length===3){ h = h.split('').map(c=>c+c).join(''); }
  const r = parseInt(h.substring(0,2),16)/255;
  const g = parseInt(h.substring(2,4),16)/255;
  const b = parseInt(h.substring(4,6),16)/255;
  const max = Math.max(r,g,b), min = Math.min(r,g,b);
  let hOut = 0, s = 0, l = (max+min)/2;
  if(max!==min){
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch(max){
      case r: hOut = (g - b) / d + (g < b ? 6 : 0); break;
      case g: hOut = (b - r) / d + 2; break;
      case b: hOut = (r - g) / d + 4; break;
    }
    hOut /= 6;
  }
  return { h:hOut, s:s, l:l };
}
function hslToHex(h, s, l){
  function hue2rgb(p, q, t){
    if(t<0) t+=1; if(t>1) t-=1;
    if(t<1/6) return p + (q - p) * 6 * t;
    if(t<1/2) return q;
    if(t<2/3) return p + (q - p) * (2/3 - t) * 6;
    return p;
  }
  let r, g, b;
  if(s===0){ r=g=b=l; }
  else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  const toHex = v => ('0' + Math.round(v*255).toString(16)).slice(-2);
  return '#' + toHex(r) + toHex(g) + toHex(b);
}
function adjustLightness(hex, deltaPct){
  const c = hexToHsl(hex);
  c.l = clamp01(c.l + deltaPct/100);
  return hslToHex(c.h, c.s, c.l);
}

function wrapTextToLines(ctx, text, maxWidth, maxLines, baseFontFamily){
  const words = text.split(/\s+/);
  const lines = [];
  let current = '';
  for(let i=0;i<words.length;i++){
    const tentative = current ? current + ' ' + words[i] : words[i];
    const w = ctx.measureText(tentative).width;
    if(w <= maxWidth){
      current = tentative;
    } else {
      if(current){ lines.push(current); }
      else { lines.push(words[i]); } // extremely long single token
      current = '';
      if(lines.length === maxLines-1){
        // Put the rest into the last line (may overflow width slightly until font adjust loop)
        current = words.slice(i+1).join(' ');
        break;
      }
    }
  }
  if(current) lines.push(current);
  if(lines.length > maxLines){
    return lines.slice(0, maxLines);
  }
  return lines;
}

function hardWrapLongToken(ctx, token, maxWidth){
  const chunks = [];
  let cur = '';
  for(let i=0;i<token.length;i++){
    const tentative = cur + token[i];
    const w = ctx.measureText(tentative).width;
    if(w <= maxWidth){
      cur = tentative;
    } else {
      if(cur) chunks.push(cur);
      cur = token[i];
    }
  }
  if(cur) chunks.push(cur);
  return chunks;
}

function wrapTextAllLines(ctx, text, maxWidth){
  const words = text.split(/\s+/);
  const lines = [];
  let current = '';
  for(let i=0;i<words.length;i++){
    const word = words[i];
    const tentative = current ? current + ' ' + word : word;
    const w = ctx.measureText(tentative).width;
    if(w <= maxWidth){
      current = tentative;
    } else {
      if(current){ lines.push(current); current = ''; }
      // If a single word is too long, hard-wrap by characters
      if(ctx.measureText(word).width > maxWidth){
        const pieces = hardWrapLongToken(ctx, word, maxWidth);
        // Push all but last piece as full lines
        for(let p=0;p<pieces.length-1;p++) lines.push(pieces[p]);
        current = pieces[pieces.length-1] || '';
      } else {
        current = word;
      }
    }
  }
  if(current) lines.push(current);
  return lines;
}

function longestWordWidth(ctx, text){
  let maxW = 0;
  const words = text.split(/\s+/);
  for(let i=0;i<words.length;i++){
    const w = ctx.measureText(words[i]).width;
    if(w > maxW) maxW = w;
  }
  return maxW;
}

function wrapTextNoBreak(ctx, text, maxWidth){
  const words = text.split(/\s+/);
  const lines = [];
  let current = '';
  for(let i=0;i<words.length;i++){
    const tentative = current ? current + ' ' + words[i] : words[i];
    const w = ctx.measureText(tentative).width;
    if(w <= maxWidth){
      current = tentative;
    } else {
      if(current) lines.push(current);
      current = words[i];
    }
  }
  if(current) lines.push(current);
  return lines;
}

function drawBoxFrame(ctx, w, h, thickness, baseHex){
  const base = (baseHex && typeof baseHex === 'string') ? baseHex : '#f4e9e0';
  const palette = {
    topLight:    adjustLightness(base, +8),  topDark:    adjustLightness(base, -2),
    rightLight:  adjustLightness(base, +2),  rightDark:  adjustLightness(base, -6),
    bottomLight: adjustLightness(base, -4),  bottomDark: adjustLightness(base, -12),
    leftLight:   adjustLightness(base, +6),  leftDark:   adjustLightness(base, -4)
  };

  // Top face
  let g = ctx.createLinearGradient(0, 0, 0, thickness);
  g.addColorStop(0, palette.topLight);
  g.addColorStop(1, palette.topDark);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.lineTo(w,0);
  ctx.lineTo(w-thickness, thickness);
  ctx.lineTo(thickness, thickness);
  ctx.closePath();
  ctx.fill();

  // Right face
  g = ctx.createLinearGradient(w - thickness, 0, w, 0);
  g.addColorStop(0, palette.rightLight);
  g.addColorStop(1, palette.rightDark);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(w,0);
  ctx.lineTo(w,h);
  ctx.lineTo(w-thickness, h-thickness);
  ctx.lineTo(w-thickness, thickness);
  ctx.closePath();
  ctx.fill();

  // Bottom face
  g = ctx.createLinearGradient(0, h - thickness, 0, h);
  g.addColorStop(0, palette.bottomLight);
  g.addColorStop(1, palette.bottomDark);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(w,h);
  ctx.lineTo(0,h);
  ctx.lineTo(thickness, h-thickness);
  ctx.lineTo(w-thickness, h-thickness);
  ctx.closePath();
  ctx.fill();

  // Left face
  g = ctx.createLinearGradient(0, 0, thickness, 0);
  g.addColorStop(0, palette.leftLight);
  g.addColorStop(1, palette.leftDark);
  ctx.fillStyle = g;
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.lineTo(0,h);
  ctx.lineTo(thickness, h-thickness);
  ctx.lineTo(thickness, thickness);
  ctx.closePath();
  ctx.fill();

  // Inner bevel line
  ctx.strokeStyle = 'rgba(0,0,0,0.18)';
  ctx.lineWidth = 1;
  ctx.strokeRect(thickness + 0.5, thickness + 0.5, w - 2*thickness - 1, h - 2*thickness - 1);
}

function drawPoster(w,h){
  poster.width = w; poster.height = h;
  pctx.clearRect(0,0,w,h);
  pctx.fillStyle = getCSS('--cover');
  pctx.fillRect(0,0,w,h);

  // Responsive box thickness (clamped)
  const thickness = Math.max(12, Math.min(Math.round(Math.min(w,h) * 0.08), Math.round(Math.min(w,h) * 0.16)));

  // Fill inner area (inside the frame) with original background color
  pctx.fillStyle = getCSS('--bg');
  pctx.fillRect(thickness, thickness, w - 2*thickness, h - 2*thickness);

  // Draw the beveled frame on top
  drawBoxFrame(pctx, w, h, thickness, '#f4e9e0');

  // Text setup
  pctx.fillStyle = '#000000';
  pctx.textAlign = 'center';
  pctx.textBaseline = 'middle';

  const present = currentHiddenPresent.toUpperCase();

  // Fit text to inner area (inside the frame)
  const innerW = Math.max(10, w - 2 * thickness);
  const innerH = Math.max(10, h - 2 * thickness);
  const maxW = innerW * 0.92;
  const maxH = innerH * 0.90; // margins

  // Determine max font size that fits by allowing as many lines as needed, without breaking words
  let size = Math.floor(innerH * 0.6);
  while(size > 8){
    pctx.font = `bold ${size}px \"Pixelify Sans\", sans-serif`;
    const maxWord = longestWordWidth(pctx, present);
    if(maxWord > maxW){ size -= 2; continue; }
    const lines = wrapTextNoBreak(pctx, present, maxW);
    const lineHeight = size * 1.01; // tighter line spacing
    const allowedLines = Math.max(1, Math.floor(maxH / lineHeight));
    if(lines.length <= allowedLines){
      // Draw centered
      const startY = thickness + (innerH - (lineHeight * lines.length)) / 2 + lineHeight/2;
      for(let i=0;i<lines.length;i++){
        pctx.fillText(lines[i], w/2, startY + i * lineHeight);
      }
      return;
    }
    size -= 2;
  }

  // Fallback: draw with minimal size without breaking words
  pctx.font = `bold ${size}px \"Pixelify Sans\", sans-serif`;
  const lines = wrapTextNoBreak(pctx, present, maxW);
  const lineHeight = size * 1.01;
  const allowedLines = Math.max(1, Math.floor(maxH / lineHeight));
  const visible = lines.slice(0, allowedLines);
  const startY = thickness + (innerH - (lineHeight * visible.length)) / 2 + lineHeight/2;
  for(let i=0;i<visible.length;i++){
    pctx.fillText(visible[i], w/2, startY + i * lineHeight);
  }
}

// ====== Canvas / sizing ======
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const stage = document.getElementById('stage');
const DPR = Math.min(1.4, Math.max(1, window.devicePixelRatio||1));

function resize(){
  const w = Math.floor(stage.clientWidth * DPR);
  const h = Math.floor(stage.clientHeight * DPR);
  canvas.width = w; canvas.height = h;
  drawPoster(w/DPR, h/DPR);
  // Ensure the custom webfont is applied once loaded
  if(document.fonts && document.fonts.ready){
    document.fonts.ready.then(()=>{ drawPoster(w/DPR, h/DPR); });
  }
  initCloth();
}
window.addEventListener('resize', resize);

// ====== Quip (sarcastic prizes) ======
const prizes = [
  // "Good" Prizes (with a twist)
  'All-inclusive trip to… your couch', 'Champagne, but warm', 'A puppy (already peed)', 
  'First-class seat (middle row)', 'Michelin dinner… with your ex', 'Free Netflix forever (ads included)', 
  'Dream sneakers (wrong size)', 'Spa day… at the DMV', 'Three weeks of massage (from Chad in finance)', 
  'A rooftop party (neighbors invited)', 'Private karaoke (with your boss)', 'Year of free coffee (decaf only)', 
  'Noise-canceling headphones (don\'t work on family)', 'Beach vacation (wifi still sucks)', 
  'Concert tickets (back row, no view)',
  
  // Truly Lame Presents
  'Expired coupon', 'Single paperclip', 'A receipt (not yours)', 'Broken pencil', 'Free dust', 
  'Half a stapler', '2% battery', 'Empty box', 'Parking ticket', 'One unread email', 
  'Used chewing gum', 'Random USB cable', 'Mystery key (to nothing)', '"World\'s Okayest" sticker', 
  'Free trial (already expired)', 'Lonely sock', 'Excel spreadsheet', 'Pocket lint', 
  'Free advice (unwanted)', 'Monday morning', 'Tariffs'
];

function setQuip(){ 
  const randomPresent = hiddenPresents[Math.floor(Math.random() * hiddenPresents.length)];
  currentHiddenPresent = randomPresent;
  
  // Redraw the poster with new hidden present
  drawPoster(canvas.width/DPR, canvas.height/DPR);
}

// ====== Controls ======
const ui = {
  thick: document.getElementById('thick'),
  brush: document.getElementById('brush'),
  eraser:document.getElementById('eraser'),
  tear:  document.getElementById('tear'),
  grav:  document.getElementById('grav'),
  toggleEraser: document.getElementById('toggle-eraser'),
  resetThick: document.getElementById('reset-thick'),
  reset: document.getElementById('reset'),
  save:  document.getElementById('save'),
  toggleHud: document.getElementById('toggle-hud'),
};

let erasing = false;
let hudCollapsed = true; // Start collapsed by default

ui.toggleEraser.addEventListener('click', ()=>toggleEraser());
ui.toggleHud.addEventListener('click', ()=>toggleHud());

function toggleEraser(){ erasing = !erasing; ui.toggleEraser.classList.toggle('toggled', erasing); }
function toggleHud(){ 
  hudCollapsed = !hudCollapsed; 
  document.getElementById('hud').classList.toggle('collapsed', hudCollapsed);
  ui.toggleHud.textContent = hudCollapsed ? '+' : '−';
}

// ====== Cloth physics ======
let cloth, boundsx=0, boundsy=0;
let physics_accuracy = 3;
let mouse_influence = 20;
let mouse_cut = 10;
let gravity = 300; // Reduced gravity for more gentle fabric movement
let cloth_height = 36;
let cloth_width  = 60;
let start_y = 0;
let spacing = 9;
let tear_distance = 40;

let visibilityTick = 0;
let physicsFrameDecimation = 1;
let frameCounter = 0;

const mouse = { down:false, button:1, x:0, y:0, px:0, py:0 };

class Point{
  constructor(x,y){ 
    this.x=x; this.y=y; this.px=x; this.py=y; this.vx=0; this.vy=0; 
    this.pin_x=null; this.pin_y=null; this.constraints=[];
    this.initialX=x; this.initialY=y; // Store initial grid coordinates
  }
  update(delta){
    if(mouse.down){
      const dx=this.x-mouse.x, dy=this.y-mouse.y, dist=Math.hypot(dx,dy);
      if(!erasing && mouse.button===1 && dist < mouse_influence){
        this.px = this.x - (mouse.x - mouse.px) * 1.8;
        this.py = this.y - (mouse.y - mouse.py) * 1.8;
      } else if(!erasing && mouse.button!==1 && dist < mouse_cut * (Number(ui.brush.value)/10)){
        // cut: remove all constraints referencing this point
        while(this.constraints.length){
          const c = this.constraints.pop(); c.active=false;
          if(c.p1!==this) c.p1.remove_constraint(c);
          if(c.p2!==this) c.p2.remove_constraint(c);
        }
      }
    }
    this.add_force(0, gravity);
    delta *= delta;
    const nx = this.x + ((this.x - this.px) * .998) + ((this.vx/2) * delta); // Increased damping
    const ny = this.y + ((this.y - this.py) * .998) + ((this.vy/2) * delta); // Increased damping
    this.px = this.x; this.py = this.y; this.x = nx; this.y = ny; this.vx = this.vy = 0;
  }
  resolve_constraints(){
    if(this.pin_x!=null && this.pin_y!=null){ this.x=this.pin_x; this.y=this.pin_y; return; }
    let i=this.constraints.length; while(i--) this.constraints[i].resolve();
    this.x > boundsx ? this.x = 2*boundsx - this.x : (this.x < 1 && (this.x = 2 - this.x));
    this.y < 1 ? this.y = 2 - this.y : (this.y > boundsy && (this.y = 2*boundsy - this.y));
  }
  attach(p){ const c = new Constraint(this,p); this.constraints.push(c); p.constraints.push(c); return c; }
  remove_constraint(c){ const i=this.constraints.indexOf(c); if(i>-1) this.constraints.splice(i,1); c.active=false; }
  add_force(x,y){ this.vx+=x; this.vy+=y; }
  pin(x,y){ this.pin_x=x; this.pin_y=y; }
}
class Constraint{
  constructor(p1,p2){ this.p1=p1; this.p2=p2; this.length=spacing; this.active=true; this.w=1; }
  resolve(){
    if(!this.active) return;
    const dx=this.p1.x-this.p2.x, dy=this.p1.y-this.p2.y;
    const dist=Math.hypot(dx,dy)||0.0001;
    const diff=(this.length-dist)/dist;
    if(dist > tear_distance){ this.active=false; this.p1.remove_constraint(this); this.p2.remove_constraint(this); return; }
    const px=dx*diff*0.5, py=dy*diff*0.5;
    this.p1.x += px; this.p1.y += py; this.p2.x -= px; this.p2.y -= py;
  }
  stroke(baseW){ if(!this.active || this.w<=0.02) return; ctx.lineWidth = Math.max(0.5, baseW * this.w); ctx.beginPath(); ctx.moveTo(this.p1.x,this.p1.y); ctx.lineTo(this.p2.x,this.p2.y); ctx.stroke(); }
}
class Cloth{
  constructor(){
    this.points=[]; 
    const start_x = 0; // Start from left edge for full coverage
    for(let y=0;y<=cloth_height;y++){
      for(let x=0;x<=cloth_width;x++){
        const p=new Point(start_x+x*spacing,start_y+y*spacing);
        if(x!==0) p.attach(this.points[this.points.length-1]);
        if(y===0) p.pin(p.x,p.y); // Pin top row firmly
        if(y!==0) p.attach(this.points[x+(y-1)*(cloth_width+1)]);
        this.points.push(p);
      }
    }
    // collect unique edges
    this.edges = collectEdges(this.points);
  }
  update(){ let i=physics_accuracy; while(i--){ let p=this.points.length; while(p--) this.points[p].resolve_constraints(); } let j=this.points.length; while(j--) this.points[j].update(0.016); }
}

function collectEdges(points){
  const set = new Set(); const edges=[];
  for(const p of points){ for(const c of p.constraints){ if(!set.has(c)){ set.add(c); edges.push(c); } } }
  return edges;
}

function initCloth(){
  gravity = Number(ui.grav.value);
  tear_distance = Number(ui.tear.value);
  mouse_influence = Number(ui.brush.value);
  boundsx = canvas.width-1; boundsy = canvas.height-1;
  
  // Calculate responsive grid dimensions to always cover the full canvas (simple targetSpacing like older version)
  const targetSpacing = Math.max(4, Math.min(8, Math.min(canvas.width, canvas.height) / 100));
  const responsiveWidth = Math.ceil(canvas.width / targetSpacing);
  const responsiveHeight = Math.ceil(canvas.height / targetSpacing);
  
  // Update cloth dimensions dynamically
  cloth_width = responsiveWidth;
  cloth_height = responsiveHeight;
  spacing = targetSpacing;
  start_y = 0; // Always start from top
  
  // Keep physics accuracy high for lively dynamics
  physics_accuracy = 3;
  
  cloth = new Cloth();
  
  // Set pattern once per cloth creation and precompute edge colors
  const userPattern = document.getElementById('pattern').value;
  cloth.currentPattern = userPattern === 'random' ? patterns[Math.floor(Math.random() * patterns.length)] : userPattern;
  recomputeEdgeColors();
  
  setQuip();
}

// Gift package patterns
const patterns = [
  'checkerboard', 'polka-dots', 'stripes', 'squares', 'circles', 'zigzag', 'diamonds', 'stars'
];

// ====== Rendering ======
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.drawImage(poster,0,0,canvas.width,canvas.height);

  // Safety check: only draw if cloth is ready
  if(!cloth || !cloth.points || cloth.points.length === 0 || !cloth.edges) return;

  // Fabric drawn as thick strokes for intact edges
  const baseStroke = spacing * Number(ui.thick.value);
  ctx.save();
  ctx.strokeStyle = getCSS('--cover');
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  
  // Batch by color+width to reduce state changes and path counts
  const buckets = new Map();
  for(const e of cloth.edges){ 
    if(!(e && e.active && e.p1 && e.p2)) continue;
    const color = e._cachedColor || getPatternColor(e, cloth.currentPattern, baseStroke);
    const width = Math.max(0.5, baseStroke * e.w);
    if(width <= 0.02) continue;
    const key = color + '|' + width.toFixed(2);
    let arr = buckets.get(key);
    if(!arr){ arr = []; buckets.set(key, arr); }
    arr.push(e);
  }
  for(const [key, edges] of buckets){
    const [color, widthStr] = key.split('|');
    ctx.strokeStyle = color;
    // Coarser quantization to reduce buckets further
    const qWidth = Math.max(0.5, Math.round(parseFloat(widthStr)));
    ctx.lineWidth = qWidth;
    ctx.beginPath();
    for(const e of edges){
      ctx.moveTo(e.p1.x, e.p1.y);
      ctx.lineTo(e.p2.x, e.p2.y);
    }
    ctx.stroke();
  }
  ctx.restore();
  

}

function update(){
  cloth.update();
  if(erasing && mouse.down && mouse.button===1){ eraserAt(mouse.x, mouse.y); }
  draw();
  requestAnimationFrame(update);
}

// ====== Mouse & Eraser ======
canvas.addEventListener('mousedown',e=>{ mouse.button=e.which; mouse.px=mouse.x; mouse.py=mouse.y; const r=canvas.getBoundingClientRect(); mouse.x=(e.clientX-r.left)*(canvas.width/r.width); mouse.y=(e.clientY-r.top)*(canvas.height/r.height); mouse.down=true; e.preventDefault(); });
canvas.addEventListener('mouseup',e=>{ mouse.down=false; e.preventDefault(); });
canvas.addEventListener('mousemove',e=>{ mouse.px=mouse.x; mouse.py=mouse.y; const r=canvas.getBoundingClientRect(); mouse.x=(e.clientX-r.left)*(canvas.width/r.width); mouse.y=(e.clientY-r.top)*(canvas.height/r.height); e.preventDefault(); });

canvas.addEventListener('contextmenu',e=> e.preventDefault());

// ====== Touch Support for Mobile ======
canvas.addEventListener('touchstart',e=>{ 
  e.preventDefault(); // Prevent scrolling
  if(e.touches.length === 1) {
    const touch = e.touches[0];
    const r = canvas.getBoundingClientRect();
    mouse.button = 1; // Left click equivalent for touch (drag)
    mouse.px = mouse.x; mouse.py = mouse.y;
    mouse.x = (touch.clientX - r.left) * (canvas.width / r.width);
    mouse.y = (touch.clientY - r.top) * (canvas.height / r.height);
    mouse.down = true;
  } else if(e.touches.length === 2) {
    // Two-finger touch = right click equivalent (tear)
    const touch = e.touches[0];
    const r = canvas.getBoundingClientRect();
    mouse.button = 2; // Right click equivalent for touch
    mouse.px = mouse.x; mouse.py = mouse.y;
    mouse.x = (touch.clientX - r.left) * (canvas.width / r.width);
    mouse.y = (touch.clientY - r.top) * (canvas.height / r.height);
    mouse.down = true;
  }
});

canvas.addEventListener('touchend',e=>{ 
  e.preventDefault();
  mouse.down = false; 
});

canvas.addEventListener('touchmove',e=>{ 
  e.preventDefault(); // Prevent scrolling
  if(e.touches.length === 1) {
    const touch = e.touches[0];
    const r = canvas.getBoundingClientRect();
    mouse.px = mouse.x; mouse.py = mouse.y;
    mouse.x = (touch.clientX - r.left) * (canvas.width / r.width);
    mouse.y = (touch.clientY - r.top) * (canvas.height / r.height);
  } else if(e.touches.length === 2) {
    // Update position for two-finger touch (tearing)
    const touch = e.touches[0];
    const r = canvas.getBoundingClientRect();
    mouse.px = mouse.x; mouse.py = mouse.y;
    mouse.x = (touch.clientX - r.left) * (canvas.width / r.width);
    mouse.y = (touch.clientY - r.top) * (canvas.height / r.height);
  }
});

function eraserAt(x,y){
  if(!cloth || !cloth.edges) return;
  
  const R = Number(ui.eraser.value);
  const dec = 0.18; // thickness decrement per pass
  for(const e of cloth.edges){ 
    if(!e.active || !e.p1 || !e.p2) continue; 
    const d = segDist(e.p1.x,e.p1.y,e.p2.x,e.p2.y,x,y); 
    if(d<R){ const t = 1 - (d/R); e.w = Math.max(0, e.w - dec*t); } 
  }
}
function segDist(x1,y1,x2,y2, x0,y0){
  const A=x0-x1, B=y0-y1, C=x2-x1, D=y2-y1; const dot=A*C+B*D; const len=C*C+D*D; let u = len? (dot/len):0; u=Math.max(0,Math.min(1,u)); const X=x1+u*C, Y=y1+u*D; const dx=X-x0, dy=Y-y0; return Math.hypot(dx,dy);
}

// ====== UI actions ======
ui.reset.addEventListener('click',()=> initCloth());
ui.resetThick.addEventListener('click',()=>{ 
  if(cloth && cloth.edges) {
    for(const e of cloth.edges){ 
      if(e && e.w !== undefined) e.w=1; 
    } 
  } 
});
ui.toggleEraser.addEventListener('click',()=> toggleEraser());
ui.grav.addEventListener('input',()=> gravity=Number(ui.grav.value));
ui.tear.addEventListener('input',()=> tear_distance=Number(ui.tear.value));
ui.brush.addEventListener('input',()=> mouse_influence=Number(ui.brush.value));
ui.thick.addEventListener('input',()=>{ recomputeEdgeColors(); });
window.addEventListener('keydown',e=>{ 
  if(e.key.toLowerCase()==='e'){ toggleEraser(); } 
  if(e.key.toLowerCase()==='h'){ toggleHud(); }
  if(e.key.toLowerCase()==='r'){ initCloth(); } 
  if((e.key.toLowerCase()==='s')&&(e.metaKey||e.ctrlKey)){ e.preventDefault(); exportPNG(); } 
});



// Mini reset button
const miniReset = document.getElementById('mini-reset');
if(miniReset){ miniReset.addEventListener('click', ()=> initCloth()); }

// Intro overlay behavior
const introEl = document.getElementById('intro');
const startBtn = document.getElementById('start-btn');
if(startBtn){
  startBtn.addEventListener('click', ()=>{
    introEl.classList.remove('show');
    introEl.classList.add('hidden');
  });
}
// Show intro on load
window.addEventListener('load', ()=>{
  requestAnimationFrame(()=>{ introEl.classList.add('show'); });
});

document.getElementById('pattern').addEventListener('change', () => {
  // When pattern changes, set and recompute colors
  const userPattern = document.getElementById('pattern').value;
  cloth.currentPattern = userPattern === 'random' ? patterns[Math.floor(Math.random() * patterns.length)] : userPattern;
  recomputeEdgeColors();
});

function exportPNG(){ const a=document.createElement('a'); a.download=`cloth-rip-${Date.now()}.png`; a.href=canvas.toDataURL('image/png'); a.click(); }
ui.save.addEventListener('click',exportPNG);

function getPatternColor(edge, pattern, baseStroke) {
  // Use initial grid coordinates, not current moving positions
  const x = edge.p1.initialX || edge.p1.x;
  const y = edge.p1.initialY || edge.p1.y;
  const spacing = baseStroke * 2;
  
  switch(pattern) {
    case 'checkerboard':
      const checkX = Math.floor(x / spacing);
      const checkY = Math.floor(y / spacing);
      return (checkX + checkY) % 2 === 0 ? '#F03B2C' : '#FFD700';
      
    case 'polka-dots':
      const dotX = Math.floor(x / spacing);
      const dotY = Math.floor(y / spacing);
      const inDot = Math.sqrt((x - dotX * spacing - spacing/2) ** 2 + (y - dotY * spacing - spacing/2) ** 2) < spacing/3;
      return inDot ? '#FF69B4' : '#F03B2C';
      
    case 'stripes':
      const stripeX = Math.floor(x / spacing);
      return stripeX % 2 === 0 ? '#F03B2C' : '#FFD700';
      
    case 'squares':
      const squareX = Math.floor(x / spacing);
      const squareY = Math.floor(y / spacing);
      const inSquare = (squareX % 2 === 0 && squareY % 2 === 0) || (squareX % 2 === 1 && squareY % 2 === 1);
      return inSquare ? '#FF69B4' : '#F03B2C';
      
    case 'circles':
      const circleX = Math.floor(x / spacing);
      const circleY = Math.floor(y / spacing);
      const inCircle = Math.sqrt((x - circleX * spacing - spacing/2) ** 2 + (y - circleY * spacing - spacing/2) ** 2) < spacing/2.5;
      return inCircle ? '#FFD700' : '#F03B2C';
      
    case 'zigzag':
      const zigX = Math.floor(x / spacing);
      const zigY = Math.floor(y / spacing);
      const zigPattern = (zigX + zigY * 2) % 4;
      return zigPattern < 2 ? '#F03B2C' : '#FF69B4';
      
    case 'diamonds':
      const diamondX = Math.floor(x / spacing);
      const diamondY = Math.floor(y / spacing);
      const diamondPattern = Math.abs(diamondX - diamondY) % 2;
      return diamondPattern === 0 ? '#FFD700' : '#F03B2C';
      
    case 'stars':
      const starX = Math.floor(x / spacing);
      const starY = Math.floor(y / spacing);
      const starPattern = (starX * 3 + starY * 2) % 5;
      return starPattern === 0 ? '#FFD700' : '#F03B2C';
      
    default:
      return '#F03B2C';
  }
}



function getCSS(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

// Cache computed pattern colors per edge to avoid recomputation every frame
function recomputeEdgeColors(){
  if(!cloth || !cloth.edges) return;
  const baseStroke = spacing * Number(ui.thick.value);
  for(const e of cloth.edges){
    if(e && e.p1 && e.p2){
      e._cachedColor = getPatternColor(e, cloth.currentPattern, baseStroke);
    }
  }
}

// Start
resize();
update();
</script>
</body>
</html> 